### LQTracking

<p align="center">
  <img width="300" src="EV.png">
</p>

Linear Quadratic Teacking problems has been explored for many years. Such problems resemble in their structure the familiar LQR problem, except for additional reference signals that appear in the cost term. The tracking problem has been found useful in many domains of engineering, and finds applications in many fields, for instance, robotics, power systems, aerospace, and more. In out work we propose a closed-form solution that tackles the challenge of the unknown reference signals. Instead of grappling with predicting entire future trajectories, our method focuses on estimating an explicit weighted integral of these elusive signals. This approach reduces the training time for the machine learning models you're using for data-driven control, and allows for simpler architecture of these models. A comparative analysis is conducted based on an energy management problem in a hybrid electrical vehicle. The proposed solution is compared to a typical Model-Predictive Control approach for several machine learning estimators, namely Linear Regression, Ridge Regression, Support Vector Machine, and Random Forest. For more information about the theoretical analysis please refer to our paper.

But theory is only half the story! We test this theory in a real-world energy management scenario for a hybrid electric vehicle üöó

## üõ†Ô∏è Under the Hood: A Glimpse into the Code
Let's peek into the engine room of this project! The provided MATLAB scripts are where the magic of our proposed solution comes to life.

The main.m script serves as the central nervous system for our simulations. üß† It kicks things off by loading real-world electric vehicle data ‚Äì actual battery voltage and current readings. It then prepares this raw data, creating an input signal $u1$ by interpolating the power data. A crucial step is the numerical computation of the Laplace transform of segments of this input signal. This is handled by repeatedly calling the MyLaplace.m function (which we'll dissect next) in a loop. This numerically computed Laplace transform, stored in the Lap variable, essentially represents the "true" value of our target integral term at different time points.

Following this, main.m sets the stage for machine learning. It constructs the regression matrices $H$ (features) and $yy$ (labels). The features in H are crafted from past samples of the input signal $u1$, and the corresponding label in $yy$ is the pre-computed Lap value. While the script includes a placeholder for training any Machine Learning model of your choice (such as Support Vector Machine (SVM) model (using fitrsvm)), it defaults to a straightforward linear regression ($rr = H \ yy$) to estimate the Laplace transform (Lap_est). This Lap_est is what our control system will actually use, simulating a real-world scenario where the true future is unknown and must be predicted. Finally, main.m fires up a Simulink model (main_sim) to run the control simulation using this estimated integral term and then generates a series of plots to visualize the performance, comparing key variables like stored energy ($E$), generated power ($p_g$), and the actual vs. estimated Laplace transforms. üìä


# üî¢ MyLaplace.m: The Numerical Integration Workhorse
At the heart of our "learnable integral" is the MyLaplace.m function, a dedicated numerical tool for approximating the single-sided Laplace transform of a sampled signal U at a specific real positive point a. üèóÔ∏è This function is designed to take a vector of signal samples $U$, the sampling time $dt$, and the evaluation point a as inputs.

Before diving into calculations, MyLaplace.m performs a series of sanity checks: ensuring a is real and positive, dt is positive, and there are enough samples in U to work with. Safety first! ‚úÖ The core of the approximation involves calculating two main components: $I_{body}$ and $I_{tail}$. $I_{body}$ is computed using a formula that incorporates the signal values (Uval) and their differences (Utag - an approximation of the derivative), weighted by exponential terms (ExpVals) and coefficients ca and cb derived from the integration point a and sampling time $dt$. $I_{tail}$ provides an estimate for the contribution of the signal's tail beyond the provided samples, assuming an average value $Uavg$. These two components are then summed to give the final approximated Laplace transform value $y$. Importantly, the function includes a warning mechanism: if the absolute ratio of $I_{tail}$ to $I_{body}$ exceeds a threshold eps1, it suggests that the estimation might be inaccurate, prompting the user to potentially adjust parameters or pad the signal. This careful numerical approximation is what allows us to generate the target values our machine learning models learn to predict.

Follow [this](https://tinyurl.com/4vz9y3u9) link to acess the data files of the electrical vehicles.
